<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>技术 on infiniteJKのBlog</title><link>https://infinitejk.github.io/categories/%E6%8A%80%E6%9C%AF/</link><description>Recent content in 技术 on infiniteJKのBlog</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Wed, 08 May 2024 11:52:18 +0800</lastBuildDate><atom:link href="https://infinitejk.github.io/categories/%E6%8A%80%E6%9C%AF/rss.xml" rel="self" type="application/rss+xml"/><item><title>Hugo 部署&amp;使用</title><link>https://infinitejk.github.io/post/hugo-blog/</link><pubDate>Wed, 08 May 2024 11:52:18 +0800</pubDate><guid>https://infinitejk.github.io/post/hugo-blog/</guid><description>Hugo部署下载hugo安装包解压到指定目录 配置环境变量 开始建站 #新建站点 hugo new site myblog cd quickstart #初始化 git init #添加主题 git submodule add https://github.com/hugo-next/hugo-theme-next.git themes/hugo-theme-next echo &amp;#34;theme = &amp;#39;hugo-theme-next&amp;#39;&amp;#34; &amp;gt;&amp;gt; hugo.toml hugo server 📝发表新文章hugo new post/my-first-post.md 部署到GitHub Pages假设你需要部署在 GitHub Pages 上，首先在GitHub上创建一个Repository，命名为：infinitejk.github.io（infinitejk替换为你的github用户名）。 在站点根目录执行 Hugo 命令生成最终页面:
hugo -t=hugo-theme-next -b=&amp;#34;https://infinitejk.github.io/&amp;#34; 如果一切顺利，所有静态页面都会生成到 public 目录，将pubilc目录里所有文件 push 到刚创建的Repository的 master 分支。
cd public git init git remote add origin https://github.com/infinitejk/infinitejk.github.io.git git add -a git commit -m &amp;#34;first commit&amp;#34; git push -u origin master Hugo ThemestackNexT</description></item><item><title>nacos</title><link>https://infinitejk.github.io/post/springcloud/</link><pubDate>Wed, 08 May 2024 11:52:18 +0800</pubDate><guid>https://infinitejk.github.io/post/springcloud/</guid><description>Eureka&amp;lt;!--spring-cloud-starter-eureka-server --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka-server&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.4.7.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- spring-cloud-starter-eureka --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.4.7.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; CAP原则C (Consistency) 强一致性 A (Avaliablity) 可用性 P (Partition tolerance) 分区容错性 CAP理论的核心根据CAP，将NoSQL数据库分成了满足CA原则、满足CP原则、满足AP原则三大类: CA: 单点集群，满足一致性，可用性的系统，通常可扩展性较差 CP: 满足一致性，分区容错性的系统,通常性能不是特别高 AP: 满足可用性，分区容错性的系统，对一致性要求较低 zookeeper和eureka的区别？作为服务注册中心，eurake比zookeeper更合适。 zookeeper保证的是CP，eureka保证的是AP(在分布式系统中，分区容错性是一定要保证的) ZooKeeper 选举leader时间长，此期间集群不可用 Eureka 各节点平等
自我保护机制（心跳）：15分钟内超过85%的节点都没有正常的心跳，认为客户端和注册中心出现网络故障，会出现以下几种情况
Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务 Eureka仍然能够接受新服务的注册和查询请求，但是不会同步到其他节点（保证当前节点可用） 当网络稳定时，当前实例新的注册信息会被同步到其他的节点上 总结：Eureka可以很好的应对网络故障导致部分节点失去联系的情况，不会像zookeeper那样使整个注册服务瘫痪 http和rpc的区别
Ribbon客户端负载均衡的工具 LB:负载均衡(load balance)——将用户的请求平摊的分配到多个服务上，从而达到系统的HA(高可用)。
集中式LB: 在服务消费方和提供方之间设置独立的LB设施，如Nginx: 向代理服务器 进程式LB: 将负载均衡的逻辑集成到消费方，消费方从注册中心获得可用的地址，在自己选择合适的服务器 Ribbon使用导入依赖*&amp;lt;!--Ribbon--&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-ribbon&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;1.4.7.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 1.4.7的Eureka中有loadBalancer就不需要导包 通过服务名去注册中心里获取可用的服务器
Feign接口和注解:</description></item><item><title>Python学习笔记</title><link>https://infinitejk.github.io/post/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link><pubDate>Wed, 08 May 2024 11:52:18 +0800</pubDate><guid>https://infinitejk.github.io/post/python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid><description>1. Python简介Python是一种高级编程语言，具有简单易学、功能强大、可移植性强、跨平台等特点。Python支持多种编程范式，包括面向对象、命令式、函数式编程。Python的语法简洁，代码可读性强，适合学习和快速开发。
Python的应用领域包括Web开发、数据分析、科学计算、机器学习、人工智能、游戏开发等。
2. Python安装Python安装非常简单，可以从Python官网下载安装包安装，也可以使用包管理工具pip进行安装。
3. Python环境配置Python安装完成后，需要配置环境变量，使其能够在命令行中直接运行。配置环境变量的方法有多种，具体取决于操作系统。
Windows环境配置在Windows系统中，可以直接在系统环境变量PATH中添加Python安装目录，或者将Python安装目录添加到PATH环境变量中。
安装地址：https://www.python.org/downloads/4. Python基本语法Python的基本语法包括变量、数据类型、运算符、条件语句、循环语句、函数、模块、类等。
4.1 变量变量是存储数据的地方，在Python中，变量不需要声明类型，可以直接赋值。
4.2 数据类型和变量4.3 字符串和编码4.4 使用list和tuplelist 列表 有序集合 L = [1,2,3] 用下标访问 L[0]=1
tuple 元组 (1,2,3)
4.5 条件判断4.6 模式匹配4.7 循环语句4.8 使用dict和setdict 字典 注意：dict的key必须是不可变对象 4.9 函数关键字参数 允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。 def person(name,age,**kw): print(&amp;#34;name:&amp;#34;,name,&amp;#34;age:&amp;#34;,age,&amp;#34;other:&amp;#34;,kw) 在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。
5. Python高级特性Python还有一些高级特性，如列表解析、生成器、异常处理、装饰器、元类等。
6. Python第三方库Python的第三方库非常丰富，涵盖了Web开发、数据分析、科学计算、机器学习、人工智能、游戏开发等领域的应用。
7. Python资源Python的资源包括书籍、教程、文档、社区、工具等。</description></item><item><title>Redis学习笔记</title><link>https://infinitejk.github.io/post/redis/</link><pubDate>Wed, 08 May 2024 11:52:18 +0800</pubDate><guid>https://infinitejk.github.io/post/redis/</guid><description>linux 下安装 Redis# 上传压缩包。移动到 /opt目录下并解压 1. 移动 mv redis-6.0.6.tar.gz /opt/ 2. 解压 tar zxvf redis-6.0.6.tar.gz 3. 编译，需要安装gcc-c++环境 yum install gcc-c++ （ubuntu下安装 apt install build-essential ） 4. make 命令 编译redis 完成后在make一次 ，最后make install 安装 5. redis的默认安装路径 /usr/local/bin 6. 新建一个目录，将配置文件拷贝过来 mkdir myconfig cp /opt/redis-6.0.6/redis.conf myconfig 7. redis默认不是后台启动的，要进行修改 vim 打开redis.conf 将daemonize no改为yes,保存，退出 8. 通过指定的配置文件启动 redis-server myconfig/redis.conf 9. 使用客户端进行连接 redis-cli -p 6379 10.关闭redis shutdown 性能测试工具redis-benchmark redis-benchmark -h localhost -p 6379 -c 100 -n 100000 基础知识16 个数据库 set key value 时出现问题，MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk 解决：将 stop-writes-on-bgsave-error 值设置为 no</description></item><item><title>springboot</title><link>https://infinitejk.github.io/post/springboot/</link><pubDate>Wed, 08 May 2024 11:52:18 +0800</pubDate><guid>https://infinitejk.github.io/post/springboot/</guid><description>mybatis开启实体类驼峰命名和数据库下划线命名自动转换mybatis: configuration: map-underscore-to-camel-case: true shiro访问某个资源时的执行流程执行认证→根据表单中username和password封装成一个token realm中接受到这个token，根据该token的username去数据库中查出该用户的信息，封装成一个对象 进行密码的校验 密码正确，登录成功→认证成功
否则，需要重新登录认证
认证成功后，再次访问资源，因为设置了权限，所以需要进行授权操作，授权的值来自数据库查询到的那个对象。 有了权限才能继续访问，否则跳转到无权限页面 注销，subject.logout() Swagger创建项目导入依赖&amp;lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.0.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.0.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; SpringBoot集成swagger后出现: Failed to start bean ‘documentationPluginsBootstrapper‘的解决方法 解决办法：添加guava依赖，springboot降级→2.5.7 直接使用 springfox-boot-starter
访问 http://localhost:8080/swagger-ui.html
直接使用3.0.0
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;springfox-boot-starter&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.0.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 访问 http://localhost:8080/swagger-ui/index.html
相关注解@Api：用在controller类，描述API接口 @ApiOperation：描述接口方法 @ApiModel：描述对象 @ApiModelProperty：描述对象属性 @ApiImplicitParams：描述接口参数 @ApiResponses：描述接口响应 @ApiIgnore：忽略接口方法 异步任务邮件任务导入依赖&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-starter-mail&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; spring: mail: username: infinitejk@163.</description></item><item><title>Spring复习笔记</title><link>https://infinitejk.github.io/post/spring%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</link><pubDate>Wed, 08 May 2024 11:52:18 +0800</pubDate><guid>https://infinitejk.github.io/post/spring%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid><description>核心部分IOC 控制反转将组件的控制权统一交给spring容器来管理,想用的时候直接到容器中去取出该组件
容器的底层：实际就是一个map，存放的是key-value型的数据
实例在容器中以单例的形式存在
DI 依赖注入从容器中取出组件的过程
通过xml配置文件来注册组件和取出组件
&amp;lt;!-- id属性：组件的id→组件的name class属性:类的全类名 --&amp;gt; &amp;lt;bean id=&amp;#34;userService&amp;#34; class=&amp;#34;com.infinite.service.UserServiceImpl&amp;#34;/&amp;gt; public void mytest1() { //加载Classpath路径下的xml格式的配置文件，初始化一个ApplicationContext的实例 👉 容器 ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&amp;#34;application.xml&amp;#34;); //还有别的获得容器的方式 //从容器中可以取出我们注册的组件 👉 getBean //getBean(String) 👉 按照组件id取出组件 UserService userService1 = (UserService) applicationContext.getBean(&amp;#34;userService&amp;#34;); //getBean(Class) 👉 按照组件类型取出组件，前提是该类型（类或接口）的组件在容器中只有一个 UserService userService2 = applicationContext.getBean(UserService.class); //getBean(String,Class) 👉 按照组件id和类型取出 UserService userService3 = applicationContext.getBean(&amp;#34;userService&amp;#34;, UserService.class); //取出来的组件可以正常调用实现类中的方法 userService1.sayHello(); userService2.sayHello(); userService3.sayHello(); } 生命周期</description></item><item><title>Vue学习笔记</title><link>https://infinitejk.github.io/post/vue%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</link><pubDate>Wed, 08 May 2024 11:52:18 +0800</pubDate><guid>https://infinitejk.github.io/post/vue%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</guid><description>配置淘宝镜像npm config set registry https://registry.npm.taobao.org
新建项目步骤新建工程 vue init webpack hello-vue 一路 选择 no
安装依赖 # 进入工程目录 cd hello-vue # 安装 vue-router npm install vue-router --save-dev # 安装 element-ui npm i element-ui -s # 安装依赖 npm install # 安装SASS加载器 cnpm install sass-loader node-sass --save-dev # 启动测试 npm run dev</description></item></channel></rss>