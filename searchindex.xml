<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>java常见问题</title><url>https://infinitejk.github.io/post/java%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url><categories><category>学习</category></categories><tags><tag>java面试题</tag></tags><content type="html"> 并发的小问题自测（javaGuide） 什么是线程和进程? 线程与进程的关系,区别及优缺点？ 说说并发与并行的区别? 为什么要使用多线程呢? 使用多线程可能带来什么问题?（内存泄漏、死锁、线程不安全等等） 创建线程有哪几种方式？（a.继承 Thread 类;b.实现 Runnable 接口;c. 使用 Executor 框架;d.使用 FutureTask） 说说线程的生命周期和状态? 什么是上下文切换? 什么是线程死锁?如何避免死锁? 说说 sleep() 方法和 wait() 方法区别和共同点? Java 内存模型（JMM）、重排序与 happens-before 原则了解吗？ synchronized 关键字、volatile 关键字 ThreadLocal 有啥用（解决了什么问题）？怎么用？原理了解吗？内存泄露问题了解吗？ 为什么要用线程池？ThreadPoolExecutor 类的重要参数了解吗？ThreadPoolExecutor 饱和策略了解吗？线程池原理了解吗？几种常见的线程池了解吗 为什么不推荐使用FixedThreadPool？如何设置线程池的大小？ AQS 了解么？原理？AQS 常用组件：Semaphore (信号量)、CountDownLatch （倒计时器） CyclicBarrier(循环栅栏) ReentrantLock 、 ReentrantReadWriteLock 、StampedLock（JDK8） CAS 了解么？原理？ Atomic 原子类 并发容器：ConcurrentHashMap 、 CopyOnWriteArrayList 、 ConcurrentLinkedQueueBlockingQueue 、ConcurrentSkipListMap Future 和 CompletableFuture JVM的小问题 什么是虚拟机？ Java 内存区域是怎么划分的？大对象放在哪个内存区域？ 垃圾回收有哪些算法？GC 的流程 什么是类加载？何时类加载？类加载流程？ 知道哪些类加载器。类加载器之间的关系？ 类加载器的双亲委派了解么？ 结合 Tomcat 说一下双亲委派（Tomcat 如何打破双亲委托机制？&hellip;）。 常见调优参数有哪些？ MySQL 学习了 MySQL 之后，务必确保自己掌握下面这些知识点：
MySQL 常用命令 ： 安全：登录、增加/删除用户、备份数据和还原数据 数据库操作： 建库建表/删库删表、用户权限分配 &hellip;&hellip; MySQL 中常用的数据类型、字符集编码 MySQL 简单查询、条件查询、模糊查询、多表查询以及如何对查询结果排序、过滤、分组&hellip;&hellip; MySQL 中使用索引、视图、存储过程、游标、触发器 &hellip;&hellip; 如果你想让自己更加了解 MySQL ，同时也是为了准备面试的话，下面这些知识点要格外注意：
索引：索引优缺点、B 树和 B+树、聚集索引与非聚集索引、覆盖索引 事务：事务、数据库事务、ACID、并发事务、事务隔离级别 存储引擎（MyISAM 和 InnoDB） 锁机制与 InnoDB 锁算法
总结 另外，我在上面也说了，如果你觉得内容比较多自己学不完或者如果你只想找到一份小厂的开发工作的话，建议你把重心放在 Java基础、数据库、常用框架、常用工具上。
像 JVM、分布式、高并发、高可用、微服务这些知识点，如果你想进大厂或者说让自己在求职的时候更有竞争力，那你就也是要多花一点时间来学习的。</content></entry><entry><title>Redis</title><url>https://infinitejk.github.io/post/redis/</url><categories><category>学习</category></categories><tags><tag>Redis学习笔记</tag></tags><content type="html"> linux 下安装 Redis # 上传压缩包。移动到 /opt目录下并解压 1. 移动 mv redis-6.0.6.tar.gz /opt/ 2. 解压 tar zxvf redis-6.0.6.tar.gz 3. 编译，需要安装gcc-c++环境 yum install gcc-c++ （ubuntu下安装 apt install build-essential ） 4. make 命令 编译redis 完成后在make一次 ，最后make install 安装 5. redis的默认安装路径 /usr/local/bin 6. 新建一个目录，将配置文件拷贝过来 mkdir myconfig cp /opt/redis-6.0.6/redis.conf myconfig 7. redis默认不是后台启动的，要进行修改 vim 打开redis.conf 将daemonize no改为yes,保存，退出 8. 通过指定的配置文件启动 redis-server myconfig/redis.conf 9. 使用客户端进行连接 redis-cli -p 6379 10.关闭redis shutdown 性能测试工具 redis-benchmark redis-benchmark -h localhost -p 6379 -c 100 -n 100000
基础知识 16 个数据库 set key value 时出现问题，MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk 解决：将 stop-writes-on-bgsave-error 值设置为 no
五大数据类型 String incr decr incrby decrby set get setex Expire key second :设置当前key的过期时间 setnx mset mget ttl: 查看过期剩余时间 msetnx 原子性 getset List Lpush list 1 Rpush list 3 Lpop Rpop lrange list 0 -1 lindex list 0 Llen list lrem list count key 移除指定数量的key ltrim list start stop 通过下标截取 rpoplpush 移除最后一个元素，添加到新的list lset list index key 更新列表中指定下标的值 linsert 插入 set sadd set hello 添加元素 smembers set 取值 sismember set key 判断key是否是set中元素 scard set 查看set的长度 srem set key 移除set集合中的指定元素 srandmember set count 随机抽出指定个数的元素 spop set 随机删除一个元素 smove set set1 key 向指定集合移动元素 sdiff set set1 差集 sinter set set1 交集 #共同好友 sunion set set1 并集 hash hset myhash field value 存值 hget myhash field 取值 hmset myhash field1 hello field2 world hmget myhash field1 field2 获取指定的key-value hgetall myhash 获取所有的key-value hdel myhash field1 删除指定的key hlen myhash 获取长度 Hexists myhash field1 判断指定字段是否存在 hkeys myhash 只获取key hvals myhash 只获取value hincrby myhash field1 5 指定字段增量 hsetnx myhash field4 hello 不存在就创建 hset user:1 name jikai hmset 多个值的存储 hash适合对象的存储，string适合存字符串 Zset(有序集合) zadd myset score key 添加元素，score是一个标识，用来排序 zadd myset score1 key1 score2 key 添加多个元素 #例子 zadd salary 3500 xiaoohong zadd salary 500 xiaolan zadd salary 1500 xiaohei zrangebyscore salary -inf +inf 从小到大排序 zrangebyscore salary -inf +inf withscores 从小到大排序带成绩 zrevrangebyscore salary 0 -1 从大打小 ############################### zrange salary 0 -1 显示所有元素 zrem salary xiaohong 移除元素 zcard salary 获取有序集合中元素的个数 zcount myset 1 3 获取指定区间的成员数量 排行榜应用
三种特殊数据类型 geospatial 地理位置 朋友定位，打车距离计算，推算地理位置信息
# 经度、纬度、名称 geoadd china:city 116.40 39.90 beijing 添加地理位置信息 geopos china:city beijing shanghai 查询地理位置 geodist china:city beijing shanghai 两地之间的距离 georadius china:city 110 30 1000 km 指定位置和半径内的所有元素 georadius china:city 110 30 1000 km withcoord withdist count 3 georadiusbymember china:city beijing 100 km 底层是 zset，可以用 zset 的命令来操作 geo
hyperloglog 基数统计的算法 （基数：集合中不重复的元素）
pfadd mykey a b c #创建第一组元素 pfcount mykey #统计 mykey中基数的数量 pfmerge mykey3 mykey1 mykey2 #合并到mykey3 bitmap 位存储（只有 0 和 1） bitmap 位图 统计用户信息，当只有两种状态 0 1 时可以使用
setbit sign 1 0 setbit sign 2 1 setbit sign 3 1 getbit sign 1 bitcount sign 统计为1的数量 事务 ==redis 单条命令是保证原子性的，redis 的事务不保证原子性== ==redis 没有隔离级别的概念== redis 事物的本质：一组命令的集合！一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行 一次性、顺序性、排他性
使用事务的步骤 正常执行事务
开启事务（multi） 命令入队（。。。。） 执行事务（exec） 放弃事务 discard
编译型异常（代码有问题，命令有问题）所有命令都不会执行 运行时异常 这一行命令不会执行，其他还是会执行
监控（watch）- 加锁
悲观锁: 认为什么时候都会出问题，无论做什么全部加锁 乐观锁：默认没有问题，更新数据的时候去判断在此期间是否有人修改过数据 MySQL 获取 version,更新时比较 version 解锁 （unwatch）
redis 实现乐观锁 使用 watch 去实现, 监控 money 对象 事务正常结束，数据在这期间没有发生变化 如果有另外一个线程改变了这个数据，事务就不会正常执行，这时候先解锁，重新获取一下最新值，再次监控执行事务
Jedis 导入 jedis 的包 &lt;!--jedis--> &lt;dependency> &lt;groupId>redis.clients&lt;/groupId> &lt;artifactId>jedis&lt;/artifactId> &lt;version>4.1.0&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>com.alibaba&lt;/groupId> &lt;artifactId>fastjson&lt;/artifactId> &lt;version>1.2.75&lt;/version> &lt;/dependency> 连接远程数据库 # 配置redis.conf文件 注释 bind 127.0.0.1 设置密码 requirepass 134567 去掉保护模式 protected-mode no 防火墙开启6379端口 整合 springboot jedis：采用的直连，多线程操作不安全，可以使用 jedis pool 连接池 更像 BIO lettuce：采用 netty,实例可以在多个线程之间共享 更像 NIO
BIO NIO 的基本概念和区别？ 同步和异步： io 操作分为两个步骤 发起 IO 请求和实际 IO 操作，同步和异步的区别在于实际 IO 操作是否阻塞，异步不需要等待处理结果， 阻塞和非阻塞： 阻塞就是要等待，非阻塞就是调用者不用等待，先去干别的事，有了结果再去通知调用者 BIO(Blocking IO) 同步阻塞 IO,数据的读写必须阻塞在一个线程内等待其完成 NIO(new IO) 同步非阻塞 AIO(Asynchronous IO) 异步非阻塞 当前 springboot 版本使用的 lettuce
导入依赖
&lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-data-redis&lt;/artifactId> &lt;/dependency> 配置文件
#远程数据库的ip地址 spring.redis.host=110.42.153.193 #端口号 spring.redis.port=6379 #连接密码 spring.redis.password=134567 使用RedisTemplate
@Autowired private RedisTemplate redisTemplate; @Test void contextLoads() { //几种数据类型的操作 // redisTemplate.opsForValue(); // redisTemplate.opsForList(); // redisTemplate.opsForSet(); // redisTemplate.opsForHash(); // redisTemplate.opsForZSet(); // redisTemplate.opsForGeo(); // redisTemplate.opsForHyperLogLog(); // redisTemplate.opsForCluster(); //集群相关的 //获取连接 // RedisConnection connection = redisTemplate.getConnectionFactory().getConnection(); // connection.flushDb(); // connection.flushAll(); redisTemplate.opsForValue().set("name","监控"); System.out.println(redisTemplate.opsForValue().get("name")); } ==redis 对象需要进行序列化==
序列化的作用
配置自己的 redisTemplate 并设置自己的序列化操作
@Configuration public class RedisConfig { @Bean //自定义RedisTemplate public RedisTemplate&lt;String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) { RedisTemplate&lt;String, Object> template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); //Json序列化配置 Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); //string的序列化 StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); //key 采用string的序列化方式 template.setKeySerializer(stringRedisSerializer); //hash的key 采用string的序列化方式 template.setHashKeySerializer(stringRedisSerializer); //value 采用jackson的序列化方式 template.setValueSerializer(jackson2JsonRedisSerializer); //hash的value 采用jackson的序列化方式 template.setHashValueSerializer(jackson2JsonRedisSerializer); template.afterPropertiesSet(); return template; } } 真实的开发中，有一个 redis 的工具类，封装了一些常用命令
Redis.conf 详解 限制客户端连接
Redis 持久化策略 RDB(Redis DataBase) 快照 过程： Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程结束，再用这个临时文件替换上次持久化的文件，主进程不进行任何io操作，对数据恢复的完整型不是非常敏感。 ==保存的文件名 dump.rdb== 缺点：最后一次持久化后的数据可能丢失
触发机制：
满足 save 规则
# 900秒内修改一次save 900 1 # 300秒内修改10次save 300 10save 60 10000 执行 flushall 命令
退出 redis
如何恢复 rdb 文件，放到 redis 启动目录即可
AOF(AppendOnlyFile) 将所有的命令全部记录下来（日志的形式） ==保存的文件名 appendonly.aof== 只记录写的操作， 默认不开启，需要手动配置 redis.config appendonly设为yes
如果 aof 文件有问题，会出现错误，启动不了 redis，需要修复 aof 文件redis-check-aof --fix 如果正常，放到启动目录就可以恢复数据库
同步策略
# appendfsync always 每一次修改都同步appendfsync everysec 每秒同步一次# appendfsync no 从不同步优点：
每一次修改都同步，文件的完整会更好 每秒同步一次，可能会丢失一秒数据 从不同步，性能最好 缺点： 对比RDB,文件更大,修复速度也较慢 aof的运行效率比rdb慢，所以redis的默认配置是rdb持久化</content></entry><entry><title>Spring Cloud学习笔记</title><url>https://infinitejk.github.io/post/springcloud/</url><categories><category>学习</category></categories><tags><tag>java学习笔记</tag></tags><content type="html"> Eureka &lt;!--spring-cloud-starter-eureka-server --> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-eureka-server&lt;/artifactId> &lt;version>1.4.7.RELEASE&lt;/version> &lt;/dependency> &lt;!-- spring-cloud-starter-eureka --> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-eureka&lt;/artifactId> &lt;version>1.4.7.RELEASE&lt;/version> &lt;/dependency> CAP原则 C (Consistency) 强一致性 A (Avaliablity) 可用性 P (Partition tolerance) 分区容错性 CAP理论的核心 根据CAP，将NoSQL数据库分成了满足CA原则、满足CP原则、满足AP原则三大类: CA: 单点集群，满足一致性，可用性的系统，通常可扩展性较差 CP: 满足一致性，分区容错性的系统,通常性能不是特别高 AP: 满足可用性，分区容错性的系统，对一致性要求较低 zookeeper和eureka的区别？ 作为服务注册中心，eurake比zookeeper更合适。 zookeeper保证的是CP，eureka保证的是AP(在分布式系统中，分区容错性是一定要保证的) ZooKeeper 选举leader时间长，此期间集群不可用 Eureka 各节点平等
自我保护机制（心跳）：15分钟内超过85%的节点都没有正常的心跳，认为客户端和注册中心出现网络故障，会出现以下几种情况
Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务 Eureka仍然能够接受新服务的注册和查询请求，但是不会同步到其他节点（保证当前节点可用） 当网络稳定时，当前实例新的注册信息会被同步到其他的节点上 总结：Eureka可以很好的应对网络故障导致部分节点失去联系的情况，不会像zookeeper那样使整个注册服务瘫痪
http和rpc的区别
Ribbon 客户端负载均衡的工具 LB:负载均衡(load balance)——将用户的请求平摊的分配到多个服务上，从而达到系统的HA(高可用)。
集中式LB: 在服务消费方和提供方之间设置独立的LB设施，如Nginx: 向代理服务器 进程式LB: 将负载均衡的逻辑集成到消费方，消费方从注册中心获得可用的地址，在自己选择合适的服务器 使用 导入依赖
&lt;!--Ribbon--> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-ribbon&lt;/artifactId> &lt;version>1.4.7.RELEASE&lt;/version> &lt;/dependency> 1.4.7的Eureka中有loadBalancer就不需要导包 通过服务名去注册中心里获取可用的服务器
Feign 接口和注解 ：
//创建一个service的接口，通过注解的value值来发现服务 @FeignClient(value = "SPRINGCLOUD-PROVIDER-DEPT") public interface DeptClientService { @RequestMapping("/dept/add") public boolean add(Dept dept); @RequestMapping("/dept/get/{id}") public Dept get(@PathVariable("id") int id); @RequestMapping("/dept/list") public List&lt;Dept> queryAll(); } //在controller层，从容器中获得这个feign的接口，调用接口中的方法 @Autowired private DeptClientService service=null; @RequestMapping("/consumer/dept/add") public boolean add(Dept dept) { return this.service.add(dept); } //最后在启动类上配置feign @EnableFeignClients(basePackages = {"com.infinite.springcloud"}) public class DeptConsumer_feign { public static void main(String[] args) { SpringApplication.run(DeptConsumer_feign.class,args); } } Hystrix 熔断：服务端 某个服务超时或者异常，引起熔断 （缺省是5秒内20次调用失败就会启动熔断机制） @HystrixCommond(value="方法名")
降级：客户端 从整体网站请求负载考虑。当某个服务熔断或者关闭后，服务将不再被调用 在客户端准备一个FallbackFactory,返回一个缺省值。
整体的服务水平下降，但是保证可用，不会直接挂掉
使用 服务熔断
&lt;!--导入依赖 spring-cloud-starter-hystrix 1.4.7 已过期--> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-hystrix&lt;/artifactId> &lt;version>2.0.0.RELEASE&lt;/version> &lt;/dependency> //配置解决方法 @GetMapping("/dept/get/{id}") @HystrixCommand(fallbackMethod = "hystrixGet") public Dept get(@PathVariable int id){ Dept dept = deptService.queryById(id); if(dept==null){ throw new RuntimeException("id=>"+id+",该用户不存在"); } return dept; } //备选方案 public Dept hystrixGet(@PathVariable int id){ return new Dept() .setDeptNo(id) .setDeptName("id=>"+id+",该用户不存在,null--@Hystrix") .setDbName("no this database in MySQL"); } //在启动类上开启该功能 @EnableHystrix public class DeptProviderHystrix_8001 { public static void main(String[] args) { SpringApplication.run(DeptProviderHystrix_8001.class,args); } } 服务降级
//客户端 DashBoard流监控 &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId> &lt;version>2.2.0.RELEASE&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-hystrix&lt;/artifactId> &lt;version>2.0.0.RELEASE&lt;/version> &lt;/dependency> //配置启动类 @SpringBootApplication @EnableHystrixDashboard public class DeptConsumer_Dashboard_9001 { public static void main(String[] args) { SpringApplication.run(DeptConsumer_Dashboard_9001.class,args); } } //配置监控url，在服务提供者 @Bean public ServletRegistrationBean hystrixMetricsStreamServlet() { ServletRegistrationBean registrationBean = new ServletRegistrationBean(new HystrixMetricsStreamServlet()); registrationBean.addUrlMappings("/actuator/hystrix.stream"); return registrationBean; }</content></entry><entry><title>常用复制</title><url>https://infinitejk.github.io/post/%E5%B8%B8%E7%94%A8%E5%A4%8D%E5%88%B6/</url><categories><category>学习</category></categories><tags><tag>java学习笔记</tag></tags><content type="html"> thymeleaf命名空间 xmlns:th="http://www.thymeleaf.org"
thymeleaf依赖 &lt;dependency> &lt;groupId>org.thymeleaf&lt;/groupId> &lt;artifactId>thymeleaf-spring5&lt;artifactId> &lt;/dependency> &lt;dependency> &lt;groupId>org.thymeleaf.extras&lt;/groupId> &lt;artifactId>thymeleaf-extras-java8time&lt;artifactId> &lt;/dependency> shiro-spring &lt;!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-spring --> &lt;dependency> &lt;groupId>org.apache.shiro&lt;/groupId> &lt;artifactId>shiro-spring&lt;/artifactId> &lt;version>1.8.0&lt;/version> &lt;/dependency> springboot项目依赖 &lt;dependencies> &lt;!--spring-cloud-dependencies --> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-dependencies&lt;/artifactId> &lt;version>2021.0.0&lt;/version> &lt;type>pom&lt;/type> &lt;scope>import&lt;/scope> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-dependencies&lt;/artifactId> &lt;version>2.6.1&lt;/version> &lt;type>pom&lt;/type> &lt;scope>import&lt;/scope> &lt;/dependency> &lt;!--mysql--> &lt;dependency> &lt;groupId>mysql&lt;/groupId> &lt;artifactId>mysql-connector-java&lt;/artifactId> &lt;version>8.0.27&lt;/version> &lt;/dependency> &lt;!--数据库连接池--> &lt;dependency> &lt;groupId>com.alibaba&lt;/groupId> &lt;artifactId>druid&lt;/artifactId> &lt;version>1.1.23&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.mybatis.spring.boot&lt;/groupId> &lt;artifactId>mybatis-spring-boot-starter&lt;/artifactId> &lt;version>2.2.0&lt;/version> &lt;/dependency> &lt;!--junit--> &lt;dependency> &lt;groupId>junit&lt;/groupId> &lt;artifactId>junit&lt;/artifactId> &lt;version>${junit.version}&lt;/version> &lt;scope>test&lt;/scope> &lt;/dependency> &lt;!--lombok--> &lt;dependency> &lt;groupId>org.projectlombok&lt;/groupId> &lt;artifactId>lombok&lt;/artifactId> &lt;version>${lombok.version}&lt;/version> &lt;/dependency> &lt;!--log4j--> &lt;dependency> &lt;groupId>log4j&lt;/groupId> &lt;artifactId>log4j&lt;/artifactId> &lt;version>${log4j.version}&lt;/version> &lt;/dependency> &lt;!--日志测试--> &lt;dependency> &lt;groupId>ch.qos.logback&lt;/groupId> &lt;artifactId>logback-core&lt;/artifactId> &lt;version>1.2.3&lt;/version> &lt;/dependency> &lt;/dependencies></content></entry><entry><title>Vue新建项目</title><url>https://infinitejk.github.io/post/vue%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url><categories><category>学习</category></categories><tags><tag>javaweb学习笔记</tag></tags><content type="html"> 配置淘宝镜像 npm config set registry https://registry.npm.taobao.org
新建项目步骤 新建工程 vue init webpack hello-vue 一路 选择 no
安装依赖 # 进入工程目录 cd hello-vue # 安装 vue-router npm install vue-router --save-dev # 安装 element-ui npm i element-ui -s # 安装依赖 npm install # 安装SASS加载器 cnpm install sass-loader node-sass --save-dev # 启动测试 npm run dev</content></entry><entry><title>Spring学习笔记</title><url>https://infinitejk.github.io/post/springboot/</url><categories><category>学习</category></categories><tags><tag>java学习笔记</tag></tags><content type="html"> springboot mybatis 开启实体类驼峰命名和数据库下划线命名自动转换 mybatis:configuration:map-underscore-to-camel-case:trueshiro 访问某个资源时的执行流程 执行认证→根据表单中username和password封装成一个token
realm中接受到这个token，根据该token的username去数据库中查出该用户的信息，封装成一个对象 进行密码的校验
密码正确，登录成功→认证成功
否则，需要重新登录认证
认证成功后，再次访问资源，因为设置了权限，所以需要进行授权操作，授权的值来自数据库查询到的那个对象。
有了权限才能继续访问，否则跳转到无权限页面
注销，subject.logout()
Swagger 创建项目 导入依赖 &lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --> &lt;dependency> &lt;groupId>io.springfox&lt;/groupId> &lt;artifactId>springfox-swagger2&lt;/artifactId> &lt;version>3.0.0&lt;/version> &lt;/dependency> &lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --> &lt;dependency> &lt;groupId>io.springfox&lt;/groupId> &lt;artifactId>springfox-swagger-ui&lt;/artifactId> &lt;version>3.0.0&lt;/version> &lt;/dependency> SpringBoot集成swagger后出现: Failed to start bean ‘documentationPluginsBootstrapper‘的解决方法 解决办法：添加guava依赖，springboot降级→2.5.7 直接使用 springfox-boot-starter
访问 http://localhost:8080/swagger-ui.html
直接使用3.0.0
&lt;dependency> &lt;groupId>io.springfox&lt;/groupId> &lt;artifactId>springfox-boot-starter&lt;/artifactId> &lt;version>3.0.0&lt;/version> &lt;/dependency> 访问 http://localhost:8080/swagger-ui/index.html
相关注解 @Api：用在controller类，描述API接口 @ApiOperation：描述接口方法 @ApiModel：描述对象 @ApiModelProperty：描述对象属性 @ApiImplicitParams：描述接口参数 @ApiResponses：描述接口响应 @ApiIgnore：忽略接口方法 异步任务 邮件任务 导入依赖 &lt;dependency> &lt;groupId>org.springframework.boot&lt;/groupId> &lt;artifactId>spring-boot-starter-mail&lt;/artifactId> &lt;/dependency> spring:mail:username:infinitejk@163.compassword:SBUEQFLVQNELPIUKhost:smtp.163.compublic void mailUtils(boolean html,String subject,String setTo) throws MessagingException { MimeMessage mimeMessage = mailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, html); helper.setSubject(subject); helper.setText("&lt;p style='color:red'>javamail发送&lt;/p>",true); helper.addAttachment("1.txt",new File("D:\\博客md文档\\blog-md-document\\note\\12-22 实习日报.txt")); helper.setTo(setTo); helper.setFrom("infinitejk@163.com"); mailSender.send(mimeMessage); } dubbo + zookeeper 下载zookeeper,添加zoo.cog文件，运行
导入依赖 pom.xml
&lt;!-- https://mvnrepository.com/artifact/org.apache.dubbo/dubbo-spring-boot-starter --> &lt;dependency> &lt;groupId>org.apache.dubbo&lt;/groupId> &lt;artifactId>dubbo-spring-boot-starter&lt;/artifactId> &lt;version>2.7.8&lt;/version> &lt;/dependency> &lt;!-- https://mvnrepository.com/artifact/com.github.sgroschupf/zkclient --> &lt;dependency> &lt;groupId>com.github.sgroschupf&lt;/groupId> &lt;artifactId>zkclient&lt;/artifactId> &lt;version>0.1&lt;/version> &lt;/dependency> &lt;!-- https://mvnrepository.com/artifact/org.apache.zookeeper/zookeeper --> &lt;dependency> &lt;groupId>org.apache.zookeeper&lt;/groupId> &lt;artifactId>zookeeper&lt;/artifactId> &lt;version>3.7.0&lt;/version> &lt;!--排除slf4j--> &lt;exclusions> &lt;exclusion> &lt;groupId>org.slf4j&lt;/groupId> &lt;artifactId>slf4j-log4j12&lt;/artifactId> &lt;/exclusion> &lt;/exclusions> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.curator&lt;/groupId> &lt;artifactId>curator-framework&lt;/artifactId> &lt;version>4.2.0&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.apache.curator&lt;/groupId> &lt;artifactId>curator-recipes&lt;/artifactId> &lt;version>4.2.0&lt;/version> &lt;/dependency> 服务提供者的流程
创建一个服务接口
写一个实现类，实现服务接口中的方法
将这个实现类注册到注册中心
public interface TicketService { String getTicket(); } import org.apache.dubbo.config.annotation.DubboService; //加上这个注解后，在启动时会被扫描到注册中心 @DubboService public class TicketServiceImpl implements TicketService{ @Override public String getTicket() { return "校外实习票"; } } 消费者的流程
获得注册中心里的服务 @DubboReference注解
pom坐标，或者和提供者路径相同的服务名 调用远端服务的方法
public class UserService { //想要获得生产者提供的票 //@Reference pom坐标，或者提供者相同的服务名 @DubboReference TicketService ticketService; //从注册中心调用服务 public void buyTicket(){ String ticket = ticketService.getTicket(); System.out.println("在注册中心拿到了"+ticket); } } springcloud Eureka &lt;!--spring-cloud-starter-eureka-server --> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-eureka-server&lt;/artifactId> &lt;version>1.4.7.RELEASE&lt;/version> &lt;/dependency> &lt;!-- spring-cloud-starter-eureka --> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-eureka&lt;/artifactId> &lt;version>1.4.7.RELEASE&lt;/version> &lt;/dependency> CAP原则 C (Consistency) 强一致性 A (Avaliablity) 可用性 P (Partition tolerance) 分区容错性 CAP理论的核心 一个分布式系统中，C、A、P最多只能同时满足两个 根据CAP，将NoSQL数据库分成了满足CA原则、满足CP原则、满足AP原则三大类: CA: 单点集群，满足一致性，可用性的系统，通常可扩展性较差 CP: 满足一致性，分区容错性的系统,通常性能不是特别高 AP: 满足可用性，分区容错性的系统，对一致性要求较低 zookeeper和eureka的区别？ 作为服务注册中心，eurake比zookeeper更合适。 zookeeper保证的是CP，eureka保证的是AP(在分布式系统中，分区容错性是一定要保证的) ZooKeeper 选举leader时间长，此期间集群不可用 Eureka 各节点平等
自我保护机制（心跳）：15分钟内超过85%的节点都没有正常的心跳，认为客户端和注册中心出现网络故障，会出现以下几种情况
Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务 Eureka仍然能够接受新服务的注册和查询请求，但是不会同步到其他节点（保证当前节点可用） 当网络稳定时，当前实例新的注册信息会被同步到其他的节点上 总结：Eureka可以很好的应对网络故障导致部分节点失去联系的情况，不会像zookeeper那样使整个注册服务瘫痪
http和rpc的区别
Ribbon 客户端负载均衡的工具 LB:负载均衡(load balance)——将用户的请求平摊的分配到多个服务上，从而达到系统的HA(高可用)。
集中式LB: 在服务消费方和提供方之间设置独立的LB设施，如Nginx: 向代理服务器
进程式LB: 将负载均衡的逻辑集成到消费方，消费方从注册中心获得可用的地址，在自己选择合适的服务器
使用 导入依赖
&lt;!--Ribbon--> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-ribbon&lt;/artifactId> &lt;version>1.4.7.RELEASE&lt;/version> &lt;/dependency> 1.4.7的Eureka中有loadBalancer就不需要导包 通过服务名去注册中心里获取可用的服务器
Feign 接口和注解 ：
//创建一个service的接口，通过注解的value值来发现服务 @FeignClient(value = "SPRINGCLOUD-PROVIDER-DEPT") public interface DeptClientService { @RequestMapping("/dept/add") public boolean add(Dept dept); @RequestMapping("/dept/get/{id}") public Dept get(@PathVariable("id") int id); @RequestMapping("/dept/list") public List&lt;Dept> queryAll(); } //在controller层，从容器中获得这个feign的接口，调用接口中的方法 @Autowired private DeptClientService service=null; @RequestMapping("/consumer/dept/add") public boolean add(Dept dept) { return this.service.add(dept); } //最后在启动类上配置feign @EnableFeignClients(basePackages = {"com.infinite.springcloud"}) public class DeptConsumer_feign { public static void main(String[] args) { SpringApplication.run(DeptConsumer_feign.class,args); } } Hystrix 熔断：服务端 某个服务超时或者异常，引起熔断 （缺省是5秒内20次调用失败就会启动熔断机制） @HystrixCommond(value="方法名")
降级：客户端 从整体网站请求负载考虑。当某个服务熔断或者关闭后，服务将不再被调用 在客户端准备一个FallbackFactory,返回一个缺省值。
整体的服务水平下降，但是保证可用，不会直接挂掉
使用 服务熔断
&lt;!--导入依赖 spring-cloud-starter-hystrix 1.4.7 已过期--> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-hystrix&lt;/artifactId> &lt;version>2.0.0.RELEASE&lt;/version> &lt;/dependency> //配置解决方法 @GetMapping("/dept/get/{id}") @HystrixCommand(fallbackMethod = "hystrixGet") public Dept get(@PathVariable int id){ Dept dept = deptService.queryById(id); if(dept==null){ throw new RuntimeException("id=>"+id+",该用户不存在"); } return dept; } //备选方案 public Dept hystrixGet(@PathVariable int id){ return new Dept() .setDeptNo(id) .setDeptName("id=>"+id+",该用户不存在,null--@Hystrix") .setDbName("no this database in MySQL"); } //在启动类上开启该功能 @EnableHystrix public class DeptProviderHystrix_8001 { public static void main(String[] args) { SpringApplication.run(DeptProviderHystrix_8001.class,args); } } 服务降级
//客户端 DashBoard流监控 &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId> &lt;version>2.2.0.RELEASE&lt;/version> &lt;/dependency> &lt;dependency> &lt;groupId>org.springframework.cloud&lt;/groupId> &lt;artifactId>spring-cloud-starter-netflix-hystrix&lt;/artifactId> &lt;version>2.0.0.RELEASE&lt;/version> &lt;/dependency> //配置启动类 @SpringBootApplication @EnableHystrixDashboard public class DeptConsumer_Dashboard_9001 { public static void main(String[] args) { SpringApplication.run(DeptConsumer_Dashboard_9001.class,args); } } //配置监控url，在服务提供者 @Bean public ServletRegistrationBean hystrixMetricsStreamServlet() { ServletRegistrationBean registrationBean = new ServletRegistrationBean(new HystrixMetricsStreamServlet()); registrationBean.addUrlMappings("/actuator/hystrix.stream"); return registrationBean; }</content></entry><entry><title>Spring复习笔记</title><url>https://infinitejk.github.io/post/spring%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url><categories/><tags><tag>java学习笔记</tag></tags><content type="html"> Spring复习笔记 核心部分 IOC 控制反转 将组件的控制权统一交给spring容器来管理,想用的时候直接到容器中去取出该组件
容器的底层：实际就是一个map，存放的是key-value型的数据
实例在容器中以单例的形式存在
DI 依赖注入 从容器中取出组件的过程
通过xml配置文件来注册组件和取出组件
&lt;!-- id属性：组件的id→组件的name class属性:类的全类名 --> &lt;bean id="userService" class="com.infinite.service.UserServiceImpl"/> public void mytest1() { //加载Classpath路径下的xml格式的配置文件，初始化一个ApplicationContext的实例 👉 容器 ApplicationContext applicationContext = new ClassPathXmlApplicationContext("application.xml"); //还有别的获得容器的方式 //从容器中可以取出我们注册的组件 👉 getBean //getBean(String) 👉 按照组件id取出组件 UserService userService1 = (UserService) applicationContext.getBean("userService"); //getBean(Class) 👉 按照组件类型取出组件，前提是该类型（类或接口）的组件在容器中只有一个 UserService userService2 = applicationContext.getBean(UserService.class); //getBean(String,Class) 👉 按照组件id和类型取出 UserService userService3 = applicationContext.getBean("userService", UserService.class); //取出来的组件可以正常调用实现类中的方法 userService1.sayHello(); userService2.sayHello(); userService3.sayHello(); } 生命周期</content></entry><entry><title>Java开发环境安装</title><url>https://infinitejk.github.io/post/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url><categories/><tags><tag>guidance</tag></tags><content type="html"> idea 2021.2.3 ultimate jdk-8u281要登录一个oracle账户 maven-3.6.3 jdk配置 网站 就是JAVA_HOME这些。</content></entry><entry><title>关于我</title><url>https://infinitejk.github.io/about.html</url><categories/><tags/><content type="html"> 一个在努力生活的普通人
java开发工程师
爱打篮球
喜欢音乐和看剧</content></entry></search>